import main.compiler
import main.ir
import main.bytecode
import main.llvm
import main.ast
import main.prelude

adt ParamToValue
	Nil
	Cons(param:IRParam, value:pointer, tail:ParamToValue)
end

adt VarToValue
	Nil
	Cons(var_:Variable, value:pointer, tail:VarToValue)
end

adt LatePHIList
	Nil
	Cons(llvmPhi:pointer, phi:PHIList, tail:LatePHIList)
end

adt LLVMCodegen
	New
	
	field context:CompilerContext
	field file:IRSourceFile
	
	field module:pointer
	field llvmFun:pointer
	field builder:pointer
	
	field params:ParamToValue
	field vars:VarToValue
	
	field latePhi:LatePHIList
end

adt IntrinsicInfo
	New
	
	field name:string
	field ret:pointer
	field params:pointer[]
	field paramsCount:i32
end

global llvm:pointer = LLVMContextCreate()

global llvmStringType:pointer = LLVMPointerType(LLVMInt8TypeInContext(llvm), 0)
global llvmI32Type:pointer = LLVMInt32TypeInContext(llvm)

global IntrinsicStringConcat:IntrinsicInfo = IntrinsicInfoCreate2("jf_string_concat", 2, llvmStringType, llvmStringType, llvmStringType)
global IntrinsicStringCmp:IntrinsicInfo = IntrinsicInfoCreate2("jf_string_compare", 2, llvmI32Type, llvmStringType, llvmStringType)



function IntrinsicInfoCreate(name:string, count:i32, ret:pointer):IntrinsicInfo
	var info = IntrinsicInfo.New
	info.name = name
	info.ret = ret
	info.params = new pointer[count]
	info.paramsCount = count
	return info
end

function IntrinsicInfoCreate2(name:string, count:i32, ret:pointer, p1:pointer, p2:pointer):IntrinsicInfo
	var info = IntrinsicInfoCreate(name, count, ret)
	info.params[0] = p1
	info.params[1] = p2
	return info
end

function RunLLVMCodegen(context:CompilerContext)
	LLVMCodegenUnits(context, context.units)
end

function LLVMCodegenUnits(context:CompilerContext, units:IRCompilationUnitList)
	var units = context.units
	while true do
		match units
		case Nil 
			return
		case Cons(unit_, tail)
			LLVMCodegenUnit(context, unit_)
			units = tail
		end
	end
end

function LLVMCodegenUnit(context:CompilerContext, unit_:IRCompilationUnit)
	var files = unit_.files
	while true do
		match files
		case Nil
			return
		case Cons(file, tail)
			LLVMCodegenFile(context, file)
			files = tail			
		end
	end
end

function LLVMCodegenFile(context:CompilerContext, file:IRSourceFile)
	var codegen = LLVMCodegenCreate(context, file)
	
	WriteLn("+++ Running llvm codegen on " + file.file.path + " +++")
	
	var fullName = file.unit_.name
	if file.file.suffix <> "" then
		fullName = fullName + "@" + file.file.suffix
	end
	
	codegen.module = LLVMModuleCreateWithNameInContext(fullName, llvm)
	
	LLVMCodegenSymbols(codegen, file.symbols)
	
	var moduleString = LLVMPrintModuleToString(codegen.module)
	
	var filePath = context.output + "/" + fullName + ".ll"
	WriteFile(filePath, moduleString)
	
	WriteLn("--- Leaving " + file.file.path + " ---")
end


function LLVMCodegenCreate(context:CompilerContext, file:IRSourceFile):LLVMCodegen
	var codegen:LLVMCodegen = LLVMCodegen.New
	codegen.context = context
	codegen.file = file
	
	return codegen
end

function LLVMCodegenSymbols(codegen:LLVMCodegen, symbols:IRSymbolList)
	while true do
		match symbols
		case Nil return
		case Cons(symbol, tail)
			LLVMCodegenSymbol(codegen, symbol)
			symbols = tail
		end
	end
end

function LLVMCodegenError(codegen:LLVMCodegen, loc:SrcLoc, message:string)
	match loc
	case At(line, col)
		WriteLn(codegen.file.file.path + "(line " + IntToStr(line + 1) + ", col " + IntToStr(col + 1) + "): LLVMCodegen Error: " + message)
	end
	Exit(1)
end

function LLVMCodegenSymbol(codegen:LLVMCodegen, symbol:IRSymbol)
	match symbol
	case ADT(adt_)
		--do nothing for adt yet
	case Global(global_)
		LLVMCodegenGlobal(codegen, global_)
	case Function(fun)
		LLVMCodegenFunction(codegen, fun)
	case other
		LLVMCodegenError(codegen, symbol.loc, "symbol not implemented")
	end
end

function MangleUnitName(unit_:IRCompilationUnit):string
	return unit_.name
end

function MangleGlobalName(global_:IRGlobalDecl):string
	return MangleUnitName(global_.symbol.owner.unit_) + ".g." + global_.symbol.name
end

function MangleFunctionName(fun:IRFunctionDecl):string
	if fun.symbol.owner.unit_.name == "main.test" and fun.symbol.name == "run" then
		return "_jf_entry_point"
	end
	
	return MangleUnitName(fun.symbol.owner.unit_) + ".fn." + fun.symbol.name
end

function LLVMCodegenGlobal(codegen:LLVMCodegen, global_:IRGlobalDecl)
	LLVMCodegenGlobalDecl(codegen, global_)
end

function LLVMCodegenGlobalDecl(codegen:LLVMCodegen, global_:IRGlobalDecl):pointer
	var gval:pointer
	var name = MangleGlobalName(global_)
	
	gval = LLVMGetNamedGlobal(codegen.module, name)
	if gval == Null() then
		var type = LLVMCodegenType(codegen, global_.type.loc, global_.type.type)		
		gval = LLVMAddGlobal(codegen.module, type, name)
	end
		
	return gval
end

function LLVMCodegenType(codegen:LLVMCodegen, loc:SrcLoc, type:IRType):pointer
	match type
	case Ref(ref)
		LLVMCodegenError(codegen, loc, "ref types must not appear in the codegen")
	case Prim(prim)
		match prim
		case Unit return LLVMVoidTypeInContext(llvm)
		case I32 return LLVMInt32TypeInContext(llvm)
		case String llvmStringType
		case Pointer return LLVMPointerType(LLVMInt8TypeInContext(llvm), 0)
		case Bool return LLVMInt1TypeInContext(llvm)
		case other LLVMCodegenError(codegen, loc, "prim type not implemented")
		end
	case ADT(adt_)
		LLVMCodegenError(codegen, loc, "adt type not implemented")
	case ADTMetaclass(decl)
		LLVMCodegenError(codegen, loc, "meta types must not appear in the codegen")
	case ArrayUnsized(elementType)
		var elTy = LLVMCodegenType(codegen, loc, elementType)
		return LLVMPointerType(elTy, 0)
	case ArraySized(elementType, size)
		LLVMCodegenError(codegen, loc, "sized array type should not appear in a compiled bytecode")
	case other
		LLVMCodegenError(codegen, loc, "type not implemented")
	end
end

function count_params(params:IRParamList):i32
	var i = 0
	while true do
		match params
		case Nil return i
		case Cons(param, tail)
			params = tail
			i = i + 1
		end
	end
end

function LLVMCodegenFunctionDecl(codegen:LLVMCodegen, fun:IRFunctionDecl):pointer
	var name = MangleFunctionName(fun)
	
	var funPtr:pointer	
	funPtr = LLVMGetNamedFunction(codegen.module, name)
	if funPtr <> Null() then
		return funPtr
	end

	var paramCount = count_params(fun.params)
	var params:pointer[] = new pointer[paramCount]
	
	var i = 0
	var paramList = fun.params
	while i < paramCount do
		match paramList
		case Cons(param, tail)
			paramList = tail
			params[i] = LLVMCodegenType(codegen, param.type.loc, param.type.type)
		end
		i = i + 1
	end
	
	var retTy = LLVMCodegenType(codegen, fun.retTy.loc, fun.retTy.type)
	
	var funTy = LLVMFunctionType(retTy, params, paramCount, false)
	
	var llvmFun = LLVMAddFunction(codegen.module, name, funTy)
	
	i = 0
	paramList = fun.params
	while i < paramCount do
		match paramList
		case Cons(param, tail)
			paramList = tail
			var llvmParam = LLVMGetParam(llvmFun, i)
			LLVMSetValueName(llvmParam, param.name)			
		end
		i = i + 1
	end
	
	return llvmFun
end

function LLVMCodegenGetIntrinsic(codegen:LLVMCodegen, info:IntrinsicInfo):pointer
	var name = info.name
	
	var funPtr:pointer	
	funPtr = LLVMGetNamedFunction(codegen.module, name)
	if funPtr <> Null() then
		return funPtr
	end
	
	var funTy = LLVMFunctionType(info.ret, info.params, info.paramsCount, false)
	var llvmFun = LLVMAddFunction(codegen.module, name, funTy)
	return llvmFun
end

function LLVMCodegenFunction(codegen:LLVMCodegen, fun:IRFunctionDecl)
	var llvmFun = LLVMCodegenFunctionDecl(codegen, fun)
	
	LLVMCodegenClearState(codegen)
	codegen.llvmFun = llvmFun
	LLVMCodegenCaptureParams(codegen, fun, llvmFun)
	
	var builder = LLVMCreateBuilderInContext(llvm)
	var bb = LLVMAppendBasicBlockInContext(llvm, llvmFun, "entry")
	LLVMPositionBuilderAtEnd(builder, bb)
	codegen.builder = builder
	
	match fun.body
	case Block(block)
		LLVMCodegenFunctionFrame(codegen, block.frame)
	case FFIImport(text)
		var argCount = count_params(fun.params)
		var argArray:pointer[] = new pointer[argCount]
		
		var i = 0
		while i < argCount do
			argArray[i] = LLVMGetParam(llvmFun, i)
			i = i + 1
		end
	
		var proxy = LLVMAddFunction(codegen.module, DecodeStr(text), LLVMGetElementType(LLVMTypeOf(llvmFun)))
		var ret = LLVMBuildCall(builder, proxy, argArray, argCount, "")
		if IsVoidType(fun.retTy.type) then
			LLVMBuildRetVoid(builder)
		else
			LLVMBuildRet(builder, ret)
		end
	end
end

function LLVMCodegenClearState(codegen:LLVMCodegen)
	codegen.vars = VarToValue.Nil
	codegen.params = ParamToValue.Nil
	codegen.latePhi = LatePHIList.Nil
end

function LLVMCodegenCaptureParams(codegen:LLVMCodegen, fun:IRFunctionDecl, llvmFun:pointer)
	var i = 0
	var params = fun.params
	while true do
		match params
		case Nil return
		case Cons(param, tail)
			params = tail
			
			var llvmParam = LLVMGetParam(llvmFun, i)
			codegen.params = ParamToValue.Cons(param, llvmParam, codegen.params)
		end
		i = i + 1
	end
end

function LLVMCodegenFunctionFrame(codegen:LLVMCodegen, frame:FunctionFrame)
	LLVMCodegenVariables(codegen, frame)
	LLVMCodegenBakeArguments(codegen, frame)
	
	LLVMCodegenPreapreBasicBlocks(codegen, frame.blocks)
	
	LLVMBuildBr(codegen.builder, frame.entry.llvmRef)
	
	LLMVCodegenBasicBlocks(codegen, frame.blocks)
	
	LLVMCodegenLatePHI(codegen)
end

function LLVMCodegenLatePHI(codegen:LLVMCodegen)
	var latePhi = codegen.latePhi
	while true do
		match latePhi
		case Nil return
		case Cons(llvmPHI, phi, tail)
			latePhi = tail
			
			var count = count_phi(phi)
			var values:pointer[] = new pointer[count]
			var bbs:pointer[] = new pointer[count]
			
			var phiList = phi
			var i = 0
			while i < count do				
				match phiList
				case Cons(block, value, tail)
					values[i] = LLVMCodegenGetValue(codegen, value)
					bbs[i] = block.llvmRef
					phiList = tail
				end
				
				i = i + 1
			end
			
			LLVMAddIncoming(llvmPHI, values, bbs, count)
		end
	end
end

function GetDbgLoc(dbg:DebugLoc):SrcLoc
	match dbg
	case At(file, loc)
		return loc
	case None
		return SrcLoc.At(0, 0)
	end
end

function GetVariableName(var_:Variable):string
	match var_
	case Var(name) return name
	case Parameter(param) return "bake." + param.name
	case other return ""
	end
end

function LLVMCodegenGetValue(codegen:LLVMCodegen, value:ValueRef):pointer
	match value
	case Instr(instr)
		return instr.llvmRef
	case ConstNum(num, type)
		return LLVMConstInt_wrap(LLVMCodegenType(codegen, SrcLoc.At(0,0), type), num, true)
	case ConstString(str, ty)
		var initializer = LLVMConstStringInContext(llvm, str, StringLength(str), false)
		var globalConstant = LLVMAddGlobal(codegen.module, LLVMTypeOf(initializer), "")
		LLVMSetLinkage(globalConstant, LLVMPrivateLinkage())
		LLVMSetInitializer(globalConstant, initializer)
		return LLVMConstBitCast(globalConstant, LLVMPointerType(LLVMInt8TypeInContext(llvm), 0))
	case ConstBool(val, type)
		var num:i32
		if val then
			num = 1
		else
			num = 0
		end
		return LLVMConstInt_wrap(LLVMCodegenType(codegen, SrcLoc.At(0,0), type), num, true)
	case other
		WriteLn("ValueRef not implemented")
		Exit(1)
	end
end

function IsVoidType(type:IRType):bool
	match type
	case Prim(prim)
		match prim
		case Unit return true
		end
	end
	return false
end

function LLVMCodegenPreapreBasicBlocks(codegen:LLVMCodegen, blocks:BasicBlockList)
	while true do
		match blocks
		case Nil return
		case Cons(block, tail)
			blocks = tail
			
			var bb = LLVMAppendBasicBlockInContext(llvm, codegen.llvmFun, "")
			block.llvmRef = bb
		end
	end
end

function LLMVCodegenBasicBlocks(codegen:LLVMCodegen, blocks:BasicBlockList)
	while true do
		match blocks
		case Nil return
		case Cons(block, tail)
			blocks = tail
			
			LLMVCodegenBasicBlock(codegen, block)
		end
	end
end

function count_values(args:ValueRefList):i32
	match args
	case Nil return 0
	case Cons(arg, tail) return 1 + count_values(tail)
	end
end

function count_phi(phi:PHIList):i32
	match phi
	case Nil return 0
	case Cons(p, q, tail) return 1 + count_phi(tail)
	end
end

adt Args
	Args(count:i32, array:pointer[])
end

function LLVMCodegenPredicate(codegen:LLVMCodegen, cmp:Comparison):i32
	match cmp
	case EQ return 32 
	case NE return 33
	case LT return 40
	case LE return 41
	case GT return 38
	case GE return 39
	end
end

function LLMVCodegenBasicBlock(codegen:LLVMCodegen, bb:BasicBlock)
	LLVMPositionBuilderAtEnd(codegen.builder, bb.llvmRef)

	var i = 0
	while i < bb.size do
		var instr = bb.instructions[i]
		
		match instr
		case WriteVariable(var_, value)
			var alloca = LLVMCodegenGetVariableStorage(codegen, var_)
			var value = LLVMCodegenGetValue(codegen, value)
			
			LLVMBuildStore(codegen.builder, value, alloca)
		case ReadVariable(var_)
			var alloca = LLVMCodegenGetVariableStorage(codegen, var_)
			
			var val = LLVMBuildLoad(codegen.builder, alloca, "")
			instr.llvmRef = val
		case ReadGlobal(global_)
			var globalVar = LLVMCodegenGlobalDecl(codegen, global_)
			var val = LLVMBuildLoad(codegen.builder, globalVar, "")
			instr.llvmRef = val
		case WriteGlobal(global_, value)
			var globalVar = LLVMCodegenGlobalDecl(codegen, global_)
			LLVMBuildStore(codegen.builder, LLVMCodegenGetValue(codegen, value), globalVar)
		case Unreachable
			LLVMBuildUnreachable(codegen.builder)
			return
		case Return(value)
			var type = ValueRefGetType(value)
			if IsVoidType(type) then
				LLVMBuildRetVoid(codegen.builder)
			else
				var value = LLVMCodegenGetValue(codegen, value)
				
				LLVMBuildRet(codegen.builder, value)
			end
			return
		case Jump(bb_ref)
			LLVMBuildBr(codegen.builder, bb_ref.llvmRef)
			return
		case CondJump(value, bbTrue, bbFalse)
			var cond = LLVMCodegenGetValue(codegen, value)
			LLVMBuildCondBr(codegen.builder, cond, bbTrue.llvmRef, bbFalse.llvmRef)
			return
		case PHI(phi)			
			var llvmPHI = LLVMBuildPhi(codegen.builder, LLVMCodegenType(codegen, GetDbgLoc(instr.dbg), instr.type), "")
			
			codegen.latePhi = LatePHIList.Cons(llvmPHI, phi, codegen.latePhi)
			
			instr.llvmRef = llvmPHI
		case CallIntrinsic(intrin, args)
			match LLVMCodegenValues(codegen, args)
			case Args(argCount, argArray)
				match intrin
				case Arith(op)
					match op
					case Plus
						instr.llvmRef = LLVMBuildAdd(codegen.builder, argArray[0], argArray[1], "")
					case Minus
						instr.llvmRef = LLVMBuildSub(codegen.builder, argArray[0], argArray[1], "")
					case Divide
						instr.llvmRef = LLVMBuildSDiv(codegen.builder, argArray[0], argArray[1], "")
					case Multiply
						instr.llvmRef = LLVMBuildMul(codegen.builder, argArray[0], argArray[1], "")
					end
				case StringConcat
					instr.llvmRef = LLVMBuildCall(codegen.builder, LLVMCodegenGetIntrinsic(codegen, IntrinsicStringConcat), argArray, argCount, "")
				case CompareBool(cmp)
					instr.llvmRef = LLVMBuildICmp(codegen.builder, LLVMCodegenPredicate(codegen, cmp), argArray[0], argArray[1], "")
				case CompareI32(cmp)
					instr.llvmRef = LLVMBuildICmp(codegen.builder, LLVMCodegenPredicate(codegen, cmp), argArray[0], argArray[1], "")
				case ComparePointer(cmp)
					var diff = LLVMBuildPtrDiff(codegen.builder, argArray[0], argArray[1], "")
					instr.llvmRef = LLVMBuildICmp(codegen.builder, LLVMCodegenPredicate(codegen, cmp), diff, LLVMConstInt_wrap(LLVMTypeOf(diff), 0, true), "")
				case CompareString(cmp)
					var diff = LLVMBuildCall(codegen.builder, LLVMCodegenGetIntrinsic(codegen, IntrinsicStringCmp), argArray, argCount, "")
					instr.llvmRef = LLVMBuildICmp(codegen.builder, LLVMCodegenPredicate(codegen, cmp), diff, LLVMConstInt_wrap(LLVMTypeOf(diff), 0, true), "")
				case other
					LLVMCodegenError(codegen, GetDbgLoc(instr.dbg), "intrinsic not implemented")
				end
			end
		case CallFunction(fun, args)
			var llvmFun = LLVMCodegenFunctionDecl(codegen, fun)
			
			match LLVMCodegenValues(codegen, args)
			case Args(argCount, argArray)
				instr.llvmRef = LLVMBuildCall(codegen.builder, llvmFun, argArray, argCount, "")
			end
		case other
			LLVMCodegenError(codegen, GetDbgLoc(instr.dbg), "instruction not implemented")
		end
		
		i = i + 1
	end
	
	if LLVMGetBasicBlockTerminator(bb.llvmRef) == Null() then
		LLVMBuildUnreachable(codegen.builder)
	end
end

function LLVMCodegenValues(codegen:LLVMCodegen, args:ValueRefList):Args
	var argCount = count_values(args)
	var argArray = new pointer[argCount]
	var argList = args
	
	var i = 0
	while i < argCount do
		match argList
		case Cons(arg, tail)
			argArray[i] = LLVMCodegenGetValue(codegen, arg)
			argList = tail
		end
		i = i + 1
	end
	
	return Args.Args(argCount, argArray)
end

function LLVMCodegenGetArgumentValue(codegen:LLVMCodegen, param:IRParam):pointer
	var params = codegen.params
	while true do
		match params
		case Nil LLVMCodegenError(codegen, param.loc, "invalid codegen: no value for param")
		case Cons(param1, value, tail)
			params = tail
			if param1 == param then
				return value
			end
		end
	end
end

function LLVMCodegenGetVariableStorage(codegen:LLVMCodegen, var_:Variable):pointer
	var vars = codegen.vars
	while true do
		match vars
		case Nil LLVMCodegenError(codegen, GetDbgLoc(var_.dbg), "invalid codegen: no value for variable")
		case Cons(var_1, value, tail)
			vars = tail
			if var_1 == var_ then
				return value
			end
		end
	end
end


function LLVMCodegenBakeArguments(codegen:LLVMCodegen, frame:FunctionFrame)
	var vars = frame.vars
	while true do
		match vars
		case Nil return
		case Cons(var_, tail)
			vars = tail
			match var_
			case Parameter(param)
				var arg = LLVMCodegenGetArgumentValue(codegen, param)
				var alloca = LLVMCodegenGetVariableStorage(codegen, var_)
				LLVMBuildStore(codegen.builder, arg, alloca)
			end			
		end
	end
	
end


function LLVMCodegenVariables(codegen:LLVMCodegen, frame:FunctionFrame)
	var vars = frame.vars
	while true do
		match vars
		case Nil return
		case Cons(var_, tail)
			vars = tail
			var varTy = LLVMCodegenType(codegen, GetDbgLoc(var_.dbg), var_.type)
			var alloca = LLVMBuildAlloca(codegen.builder, varTy, GetVariableName(var_))

			codegen.vars = VarToValue.Cons(var_, alloca, codegen.vars)
		end
	end	
end


